# 詳細設計書

以下では、上記基本設計を踏まえ、各モジュール・テーブル・API・画面ごとに詳細な仕様を定義します。

---

## 1. データベース設計（DDL／RLSポリシー）

### 1-1. game_sessions テーブル

#### ゲームセッション情報
```sql
create table public.game_sessions (
  id uuid primary key default uuid_generate_v4(),
  status text not null check (status in ('waiting', 'playing', 'finished')),
  round int not null check (round between 1 and 4),
  created_by uuid not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

#### RLS 設定
```sql
alter table public.game_sessions enable row level security;

create policy "public select game_sessions"
  on public.game_sessions
  for select
  using ( true );

create policy "authenticated insert game_sessions"
  on public.game_sessions
  for insert
  with check ( auth.role() = 'authenticated' );

create policy "owner update game_sessions"
  on public.game_sessions
  for update
  using ( auth.uid() = created_by )
  with check ( auth.uid() = created_by );

create policy "owner delete game_sessions"
  on public.game_sessions
  for delete
  using ( auth.uid() = created_by );
```

### 1-2. participants テーブル

#### ゲーム参加者情報
```sql
create table public.participants (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null,
  game_session_id uuid not null references public.game_sessions(id) on delete cascade,
  joined_at timestamptz not null default now()
);
```

#### RLS 設定
```sql
alter table public.participants enable row level security;

create policy "public select participants"
  on public.participants
  for select
  using ( true );

create policy "authenticated insert participants"
  on public.participants
  for insert
  with check ( auth.role() = 'authenticated' );
```

### 1-3. game_items テーブル

#### ゲーム内の各ラウンド案件情報
```sql
create table public.game_items (
  id uuid primary key default uuid_generate_v4(),
  game_session_id uuid not null references public.game_sessions(id) on delete cascade,
  round int not null check (round between 1 and 4),
  project_number int not null check (project_number between 1 and 5),
  title text not null,
  cost int not null,
  min_price int not null,
  max_price int not null,
  created_at timestamptz not null default now()
);
```

#### RLS 設定
```sql
alter table public.game_items enable row level security;

create policy "public select game_items"
  on public.game_items
  for select
  using ( true );

create policy "owner insert game_items"
  on public.game_items
  for insert
  using ( auth.uid() = (
    select created_by from public.game_sessions where id = game_session_id
  ))
  with check ( auth.uid() = (
    select created_by from public.game_sessions where id = game_session_id
  ));

create policy "owner update game_items"
  on public.game_items
  for update
  using ( auth.uid() = (
    select created_by from public.game_sessions where id = game_session_id
  ))
  with check ( auth.uid() = (
    select created_by from public.game_sessions where id = game_session_id
  ));

create policy "owner delete game_items"
  on public.game_items
  for delete
  using ( auth.uid() = (
    select created_by from public.game_sessions where id = game_session_id
  ));
```

### 1-4. entries テーブル

#### 各ラウンドの入札エントリー情報
```sql
create table public.entries (
  id uuid primary key default uuid_generate_v4(),
  game_session_id uuid not null references public.game_sessions(id) on delete cascade,
  participant_id uuid not null references public.participants(id) on delete cascade,
  round int not null check (round between 1 and 4),
  project_number int not null check (project_number between 1 and 5),
  price numeric(10,1) null,
  base_location text null,
  created_at timestamptz not null default now()
);
```

#### RLS 設定
```sql
alter table public.entries enable row level security;

create policy "public select entries"
  on public.entries
  for select
  using ( true );

create policy "owner insert entries"
  on public.entries
  for insert
  using (
    auth.uid() = (
      select user_id from public.participants where id = participant_id
    )
  )
  with check (
    auth.uid() = (
      select user_id from public.participants where id = participant_id
    )
  );

create policy "owner update entries"
  on public.entries
  for update
  using (
    auth.uid() = (
      select user_id from public.participants where id = participant_id
    )
  )
  with check (
    auth.uid() = (
      select user_id from public.participants where id = participant_id
    )
  );

create policy "owner delete entries"
  on public.entries
  for delete
  using (
    auth.uid() = (
      select user_id from public.participants where id = participant_id
    )
  );
```

### 1-5. results テーブル

#### 各ラウンドの集計結果情報
```sql
create table public.results (
  id uuid primary key default uuid_generate_v4(),
  game_session_id uuid not null references public.game_sessions(id) on delete cascade,
  round int not null check (round between 1 and 4),
  project_number int not null check (project_number between 1 and 5),
  winner_participant_id uuid not null references public.participants(id),
  winning_price numeric(10,1) not null,
  profit_winner int not null,
  profit_losers jsonb not null,
  created_at timestamptz not null default now()
);
```

#### RLS 設定
```sql
alter table public.results enable row level security;

create policy "public select results"
  on public.results
  for select
  using ( true );

create policy "service role insert results"
  on public.results
  for insert
  with check ( true );

create policy "service role update results"
  on public.results
  for update
  using ( false );

create policy "service role delete results"
  on public.results
  for delete
  using ( false );
```

---

## 2. API詳細設計

以下、各エンドポイントごとにリクエスト/レスポンス仕様、バリデーション、エラーコードを定義します。

### 2-1. POST /api/game

- 説明: 新規ゲームセッションを作成し、リクエストしたユーザーを参加者として登録
- 認証: Supabase Auth の JWT 必須
- リクエストヘッダー:
  - Authorization: Bearer <token>
- リクエストボディ（JSON）:
```json
{
  "created_by": "<supabase_auth_user_id>"
}
```
- バリデーション:
  - created_by が必須・UUID形式であること
  - 同一ユーザーが1セッション内に2回呼び出せないようフロント側で制御（サーバー側では参加者投げきりチェック）
- 処理内容:
  1. game_sessions テーブルに新規レコードを挿入 (status = 'waiting', round = 1, created_by = <user_id>)
  2. 挿入された id を取得し、participants テーブルに { user_id, game_session_id: <new_id> } を insert
  3. レスポンスとして { game_session: {...} } を返す
- 正常レスポンス (201 Created):
```json
{
  "game_session": {
    "id": "xxxx-xxxx-xxxx",
    "status": "waiting",
    "round": 1,
    "created_by": "<user_id>",
    "created_at": "2025-06-10T12:00:00Z",
    "updated_at": "2025-06-10T12:00:00Z"
  }
}
```
- エラーケース:
  - 400 Bad Request: created_by が欠落 or UUID 形式でない
  - 401 Unauthorized: 認証トークン不正
  - 500 Internal Server Error: DB 挿入時例外

---

### 2-2. POST /api/game/[id]/join

- 説明: 指定のゲームセッションに参加者を追加。参加者が3人になったら game_sessions.status='playing' に更新
- 認証: JWT 必須
- パスパラメータ:
  - id: 参加先の game_sessions.id (UUID)
- リクエストボディ（JSON）:
```json
{
  "user_id": "<supabase_auth_user_id>"
}
```
- バリデーション:
  - user_id が必須・UUID形式
  - game_sessions.id = id が存在し、status='waiting' であること
  - 同一セッションに同一ユーザーがすでに参加していないこと
  - 参加者数が既に3人を超えていないこと
- 処理内容:
  1. participants に { user_id, game_session_id: id } を insert
  2. 現在の参加者数を SELECT COUNT(*) FROM participants WHERE game_session_id = id で取得
  3. 参加者数が3に達したら、game_sessions.status = 'playing' に update
  4. レスポンス { participant: { id, user_id, game_session_id, joined_at } } を返す
- 正常レスポンス (200 OK または 201 Created):
```json
{
  "participant": {
    "id": "yyyy-yyyy-yyyy",
    "user_id": "<user_id>",
    "game_session_id": "<id>",
    "joined_at": "2025-06-10T12:05:00Z"
  }
}
```
- エラーケース:
  - 400 Bad Request: フォーマット不正 or 参加済み
  - 404 Not Found: game_sessions.id が存在しない
  - 403 Forbidden: すでに3人が参加済み (参加できない)
  - 500 Internal Server Error

---

### 2-3. GET /api/game/[id]

- 説明: ゲームセッションの詳細情報と参加者リストを取得
- 認証: JWT 必須
- パスパラメータ:
  - id: game_sessions.id (UUID)
- 処理内容:
  1. SELECT * FROM game_sessions WHERE id = id
  2. SELECT p.id, p.user_id, u.email, p.joined_at FROM participants p JOIN users u ON p.user_id = u.id WHERE p.game_session_id = id
  3. レスポンス { id, status, round, created_by, participants: [ { participant の情報 }, ... ] }
- 正常レスポンス (200 OK):
```json
{
  "id": "xxxx-xxxx-xxxx",
  "status": "waiting",
  "round": 1,
  "created_by": "<user_id>",
  "participants": [
    { "id": "p1", "user_id": "uA", "email": "A@example.com", "joined_at": "…" },
    { "id": "p2", "user_id": "uB", "email": "B@example.com", "joined_at": "…" }
  ]
}
```
- エラーケース:
  - 404 Not Found: game_sessions.id が存在しない
  - 500 Internal Server Error

---

### 2-4. GET /api/game/[id]/round/[n]/items

- 説明: ラウンド n の案件リスト（5件）を返す
- 認証: JWT 必須
- パスパラメータ:
  - id: game_sessions.id (UUID)
  - n: ラウンド番号 (1～4)
- バリデーション:
  - n が整数かつ 1 ≤ n ≤ 4
  - game_sessions.id が存在
- 処理内容:
  1. SELECT project_number, title, cost, min_price, max_price FROM game_items WHERE game_session_id = id AND round = n ORDER BY project_number ASC
  2. レスポンス: 配列 [ { project_number, title, cost, min_price, max_price }, ... ]
- 正常レスポンス (200 OK):
```json
[
  { "project_number": 1, "title": "工事1", "cost": 110, "min_price": 100, "max_price": 140 },
  { "project_number": 2, "title": "工事2", "cost": 120, "min_price": 110, "max_price": 150 }
  // ... 計5件
]
```
- エラーケース:
  - 400 Bad Request: n が 1～4 以外
  - 404 Not Found: 該当 game_items が存在しない（例えばセッションとラウンド組み合わせのレコードがない場合）
  - 500 Internal Server Error

---

### 2-5. POST /api/game/[id]/round/[n]/entry

- 説明: プレイヤーの入札情報を登録
- 認証: JWT 必須
- パスパラメータ:
  - id: game_sessions.id (UUID)
  - n: ラウンド番号 (1～4)
- リクエストボディ（JSON）:
  - ラウンド 1,2,4 の場合
```json
{
  "participant_id": "<participants.id>",
  "project_number": 3,
  "price": 123.4
}
```
  - ラウンド 3（本拠地選択 & 入札）
```json
{
  "participant_id": "<participants.id>",
  "project_number": 2,
  "price": null,
  "base_location": "関東"
}
```
- バリデーション:
  - participant_id, project_number が必須
  - n に応じて price または base_location の片方が必須
  - price の場合は min_price <= price <= max_price かつ 少数第一位まで
  - base_location は (東北/関東/中部/関西/西南日本)
  - 同一プレイヤーが同じセッション/ラウンド/案件に対して二重登録しない
- 処理内容:
  1. INSERT INTO entries (game_session_id, participant_id, round, project_number, price, base_location) VALUES (...)
  2. 登録後、現在のエントリー数を SELECT COUNT(*) FROM entries WHERE game_session_id = id AND round = n で取得
  3. プレイヤー数（3人）とエントリー数（合計3件）が一致したかを判定。合致していれば、バックグラウンドでPOST /api/game/[id]/round/[n]/calculateエンドポイントを呼び出して結果を算出（もしくはクライアントが自動でGET /.../resultを呼び出す）
  4. レスポンス { entry: { id, ... } } を返す
- 正常レスポンス (201 Created):
```json
{
  "entry": {
    "id": "eeee-eeee-eeee",
    "game_session_id": "<id>",
    "participant_id": "<participant_id>",
    "round": n,
    "project_number": 3,
    "price": 123.4,
    "base_location": null,
    "created_at": "2025-06-10T12:10:00Z"
  }
}
```
- エラーケース:
  - 400 Bad Request: フォーマット不正、金額レンジ外、本拠地未選択など
  - 404 Not Found: game_sessions.id or participants.id が存在しない
  - 403 Forbidden: ラウンド番号不正 or 参加者がそのゲームに所属していない
  - 500 Internal Server Error

---

### 2-6. GET /api/game/[id]/round/[n]/result

- 説明: ラウンド n の落札者および各プレイヤーの利益を計算して返す
- 認証: JWT 必須
- パスパラメータ:
  - id: game_sessions.id
  - n: ラウンド番号
- 前提: エントリー数がすでに3件揃っていること
- 処理内容:
  1. entries から game_session_id = id, round = n の全レコードを取得
  2. ラウンドごとにロジックを分岐（詳細は省略）
  3. 結果を results テーブルに INSERT
```sql
INSERT INTO results (
  game_session_id, round, project_number, winner_participant_id,
  winning_price, profit_winner, profit_losers
) VALUES (
  id, n, <project_number>, <winner_id>,
  <winning_price>, <profit_winner>, '{"<loser1_id>": <profit1>, "<loser2_id>": <profit2>}'
);
```
  4. レスポンス:
```json
{
  "winners": [
    {
      "participant_id": "<winner_id>",
      "project_number": <project_number>,
      "winning_price": <winning_price>,
      "profit": <profit_winner>
    }
  ],
  "profits": {
    "<participantA_id>": <cumulative_profitA>,
    "<participantB_id>": <cumulative_profitB>,
    "<participantC_id>": <cumulative_profitC>
  }
}
```
- エラーケース:
  - 400 Bad Request: round が 1～4 以外
  - 404 Not Found: 該当エントリーまたは game_session が存在しない
  - 409 Conflict: エントリー数がまだ3件揃っていない
  - 500 Internal Server Error

---

### 2-7. GET /api/game/[id]/summary

- 説明: 全ラウンド終了後、累積利益ランキングを返す
- 認証: JWT 必須
- パスパラメータ:
  - id: game_sessions.id (UUID)
- 前提: game_sessions.status='finished' であること
- 処理内容:
  1. SELECT participant_id, SUM(profit_winner or profit_losers) AS total_profit FROM results GROUP BY participant_id
  2. 結果を ORDER BY total_profit DESC
  3. レスポンス: { rankings: [ { participant_id, total_profit }, ... ] }
- 正常レスポンス (200 OK):
```json
{
  "rankings": [
    { "participant_id": "A", "total_profit": 30 },
    { "participant_id": "B", "total_profit": 10 },
    { "participant_id": "C", "total_profit": -4 }
  ]
}
```
- エラーケース:
  - 404 Not Found: 該当セッションが存在しない
  - 409 Conflict: status != 'finished' のため集計できない
  - 500 Internal Server Error

---

## 3. フロントエンド詳細設計

### 3-1. 共通コンポーネント

#### 1. NavBar.tsx
- ログイン状態に応じて「サインイン/サインアップ」「マイページ/ロビー」「ログアウト」を表示
- ゲーム中は現在のラウンド (useContext or useSession) を表示
- 各ページで必ず読み込む（app/layout.tsx に配置）
```tsx
"use client";
import Link from "next/link";
import { useSession, useSupabaseClient } from "@supabase/auth-helpers-react";
import { useRouter } from "next/navigation";

export default function NavBar() {
  const session = useSession();
  const supabase = useSupabaseClient();
  const router = useRouter();

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    router.push("/signin");
  };

  return (
    <nav className="bg-gray-800 text-white p-4 flex justify-between items-center">
      <div>
        <Link href="/" className="font-bold text-xl">入札シミュレーション</Link>
      </div>
      <div className="space-x-4">
        {session ? (
          <>
            <Link href="/lobby">ロビー</Link>
            <button onClick={handleSignOut}>ログアウト</button>
          </>
        ) : (
          <>
            <Link href="/signin">サインイン</Link>
            <Link href="/signup">サインアップ</Link>
          </>
        )}
      </div>
    </nav>
  );
}
```

#### 2. LoadingSpinner.tsx（共通ローディング表示）
```tsx
export default function LoadingSpinner() {
  return (
    <div className="flex justify-center items-center h-full">
      <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-blue-500"></div>
    </div>
  );
}
```

#### 3. ErrorMessage.tsx
```tsx
export default function ErrorMessage({ message }: { message: string }) {
  return (
    <div className="bg-red-100 text-red-700 p-2 rounded mb-4">
      {message}
    </div>
  );
}
```

---

### 3-2. ページ／コンテナ設計

（以降のページ設計・コード例も、各セクション・サブセクションごとに `##`/`###`/`-`/番号付きリスト/コードブロック（tsx, ts, js, json等）で統一してください。）

3-2-1. ロビー画面 (/app/lobby/page.tsx)
	•	役割：
	•	「新規ゲーム作成」ボタンで POST /api/game を呼び出し、自分を参加者として登録
	•	「参加可能なゲーム一覧」を GET /api/game の一覧から抽出し、ボタンで参加
	•	参加済みの場合は自動的に /game/[id] へリダイレクト
	•	実装詳細：

"use client";

import { useEffect, useState } from "react";
import { useSupabaseClient, useSession } from "@supabase/auth-helpers-react";
import { useRouter } from "next/navigation";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";

type GameSession = {
  id: string;
  status: "waiting" | "playing" | "finished";
  round: number;
  participants: { id: string; user_id: string; joined_at: string }[];
};

export default function LobbyPage() {
  const supabase = useSupabaseClient();
  const session = useSession();
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [waitingGames, setWaitingGames] = useState<GameSession[]>([]);

  // 1. 未ログイン → /signin にリダイレクト
  useEffect(() => {
    if (session === null) {
      router.push("/signin?redirectTo=/lobby");
    }
  }, [session, router]);

  // 2. session undefined 時はローディング
  if (session === undefined) return <LoadingSpinner />;

  // 3. session null 時は何も表示しない（リダイレクト中）
  if (session === null) return null;

  // 4. 参加可能リスト取得
  useEffect(() => {
    const fetchWaiting = async () => {
      try {
        const resp = await fetch("/api/game");
        const data: { sessions: GameSession[] } = await resp.json();
        const filtered = data.sessions.filter((g) => g.status === "waiting");
        setWaitingGames(filtered);
      } catch (e) {
        setError("ゲーム一覧の取得に失敗しました");
      } finally {
        setLoading(false);
      }
    };
    fetchWaiting();
  }, []);

  // 5. 新規ゲーム作成
  const handleCreate = async () => {
    setLoading(true);
    try {
      const resp = await fetch("/api/game", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ created_by: session.user.id }),
      });
      const json = await resp.json();
      if (!resp.ok) throw new Error(json.error);
      router.push(`/game/${json.game_session.id}`);
    } catch (e: any) {
      setError(e.message || "ゲーム作成に失敗しました");
    } finally {
      setLoading(false);
    }
  };

  // 6. 参加ボタン
  const handleJoin = async (gameId: string) => {
    setLoading(true);
    try {
      const resp = await fetch(`/api/game/${gameId}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: session.user.id }),
      });
      const json = await resp.json();
      if (!resp.ok) throw new Error(json.error);
      router.push(`/game/${gameId}`);
    } catch (e: any) {
      setError(e.message || "参加に失敗しました");
    } finally {
      setLoading(false);
    }
  };

  return (
    <main className="p-6 max-w-lg mx-auto">
      <h1 className="text-2xl font-bold mb-4">ロビー</h1>
      {error && <ErrorMessage message={error} />}
      <button
        onClick={handleCreate}
        className="bg-blue-600 text-white px-4 py-2 rounded mb-4"
        disabled={loading}
      >
        {loading ? "処理中..." : "新規ゲームを作成"}
      </button>
      <h2 className="text-xl mb-2">参加可能なゲーム一覧</h2>
      {loading ? (
        <LoadingSpinner />
      ) : waitingGames.length === 0 ? (
        <p>参加できるゲームはありません。</p>
      ) : (
        <ul className="space-y-2">
          {waitingGames.map((g) => (
            <li key={g.id} className="flex justify-between items-center border p-2 rounded">
              <span>セッションID: {g.id} (参加者: {g.participants.length}/3)</span>
              <button
                onClick={() => handleJoin(g.id)}
                className="bg-green-500 text-white px-3 py-1 rounded"
                disabled={loading}
              >
                参加
              </button>
            </li>
          ))}
        </ul>
      )}
    </main>
  );
}



3-2-2. ラウンド共通レイアウト
	•	ファイル名：/app/game/[session_id]/round/[round]/layout.tsx
	•	役割：
	•	URL パス /game/[session_id]/round/[round] 以下のページをラップし、共通 NavBar と進捗表示を行う
	•	context.params から session_id と round を取得し、現在のラウンドを画面上部に表示
	•	子要素として個別ラウンドのフォームや結果を表示

"use client";
import { ReactNode, useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { useParams } from "next/navigation";
import NavBar from "@/components/NavBar";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";

export default function RoundLayout({ children }: { children: ReactNode }) {
  const params = useParams() as { session_id: string; round: string };
  const { session_id, round } = params;
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [status, setStatus] = useState<"waiting" | "playing" | "finished">("waiting");
  const [error, setError] = useState<string | null>(null);

  // ゲームステータスを取得し、正しいラウンドかチェック
  useEffect(() => {
    const fetchSession = async () => {
      try {
        const res = await fetch(`/api/game/${session_id}`);
        const json = await res.json();
        if (!res.ok) throw new Error(json.error);
        if (json.round !== Number(round) || json.status !== "playing") {
          // 正しいラウンドでなければリダイレクト
          router.push(`/game/${session_id}/round/${json.round}`);
        } else {
          setStatus(json.status);
        }
      } catch (e: any) {
        setError("セッション情報の取得に失敗");
      } finally {
        setLoading(false);
      }
    };
    fetchSession();
  }, [session_id, round, router]);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (status !== "playing") return null;

  return (
    <>
      <NavBar />
      <div className="p-6 max-w-xl mx-auto">
        <h2 className="text-xl font-semibold mb-4">ラウンド {round}</h2>
        {children}
      </div>
    </>
  );
}

3-2-3. ラウンド1/2 入札フォーム (/app/game/[session_id]/round/1/page.tsx 他)
	•	ファイル名：/app/game/[session_id]/round/[round]/page.tsx
	•	ロジック：
	1.	useEffect で GET /api/game/[id]/round/[round]/items を呼び、案件リストを取得
	2.	テーブル化して「工事番号・タイトル・工事原価・最低/最高価格」を表示
	3.	ユーザーが「価格」を入力し、「入札する」ボタンを押すと POST /api/game/[id]/round/[round]/entry を実行
	4.	すでに自分がエントリー済みの場合、価格入力欄を非活性化して「登録済みマーク」を表示
	5.	他の 2 人も入力済みかを定期的に GET /api/game/[id] でチェックし、全員入力完了 → 自動的に GET /api/game/[id]/round/[round]/result を呼び出し
	6.	結果が返ってきたら /result ページにリダイレクト

"use client";

import { useEffect, useState } from "react";
import { useSupabaseClient, useSession } from "@supabase/auth-helpers-react";
import { useRouter, useParams } from "next/navigation";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";

type Item = {
  project_number: number;
  title: string;
  cost: number;
  min_price: number;
  max_price: number;
};

type Entry = {
  id: string;
  participant_id: string;
  project_number: number;
  price: number;
  base_location: string | null;
};

export default function RoundBidPage() {
  const supabase = useSupabaseClient();
  const session = useSession();
  const router = useRouter();
  const { session_id, round } = useParams() as { session_id: string; round: string };
  const [items, setItems] = useState<Item[]>([]);
  const [priceInputs, setPriceInputs] = useState<Record<number, string>>({});
  const [entries, setEntries] = useState<Entry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [submitting, setSubmitting] = useState(false);

  // 1. 未ログインなら /signin へリダイレクト
  useEffect(() => {
    if (session === null) {
      router.push("/signin?redirectTo=/game/" + session_id + "/round/" + round);
    }
  }, [session, router, session_id, round]);

  // 2. ラウンド案件取得 & 既存エントリー取得
  useEffect(() => {
    const fetchData = async () => {
      try {
        const res1 = await fetch(`/api/game/${session_id}/round/${round}/items`);
        const json1 = await res1.json();
        if (!res1.ok) throw new Error(json1.error);
        setItems(json1);

        const res2 = await fetch(`/api/game/${session_id}`); // 参加者人数チェックや既エントリー取得に使う
        const json2 = await res2.json();
        const allEntries = await fetch(`/api/game/${session_id}/round/${round}/entries`);
        const json3 = await allEntries.json();
        if (!allEntries.ok) throw new Error(json3.error);
        setEntries(json3.entries);

        setLoading(false);
      } catch (e: any) {
        setError("案件情報の取得に失敗しました");
        setLoading(false);
      }
    };
    fetchData();
  }, [session_id, round]);

  // 3. 入札送信
  const handleSubmit = async (projectNumber: number) => {
    const inputValue = priceInputs[projectNumber];
    if (!inputValue) {
      setError("価格を入力してください");
      return;
    }
    const price = parseFloat(inputValue);
    const item = items.find((i) => i.project_number === projectNumber);
    if (!item) return;
    if (price < item.min_price || price > item.max_price) {
      setError(`価格は${item.min_price}～${item.max_price}の間で入力してください`);
      return;
    }

    setSubmitting(true);
    setError(null);

    try {
      const resp = await fetch(`/api/game/${session_id}/round/${round}/entry`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          participant_id: session.user.id, // participants.id と合わせる想定
          project_number: projectNumber,
          price,
        }),
      });
      const json = await resp.json();
      if (!resp.ok) throw new Error(json.error);
      // 登録後：エントリー一覧更新
      setEntries((prev) => [...prev, json.entry]);
    } catch (e: any) {
      setError(e.message || "登録に失敗しました");
    } finally {
      setSubmitting(false);
    }
  };

  // 4. 3 人分揃ったら結果表示へ自動遷移
  useEffect(() => {
    if (entries.filter((e) => e.round === Number(round)).length === 3) {
      router.push(`/game/${session_id}/round/${round}/result`);
    }
  }, [entries, session_id, round, router]);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div className="space-y-4">
      <h3 className="text-lg font-semibold">ラウンド {round} の案件一覧</h3>
      {items.map((item) => (
        <div key={item.project_number} className="border rounded p-3 flex items-center justify-between">
          <div>
            <p>案件 {item.project_number}：{item.title}</p>
            <p>工事原価：{item.cost} 億円 (範囲 {item.min_price}～{item.max_price} 億円)</p>
          </div>
          <div>
            {/* すでにエントリー済みなら表示を変える */}
            {entries.some((e) => e.project_number === item.project_number) ? (
              <button disabled className="bg-gray-400 text-white px-3 py-1 rounded">登録済</button>
            ) : (
              <div className="flex space-x-2">
                <input
                  type="number"
                  step="0.1"
                  min={item.min_price}
                  max={item.max_price}
                  placeholder={`${item.min_price}～${item.max_price}`}
                  value={priceInputs[item.project_number] || ""}
                  onChange={(e) =>
                    setPriceInputs((prev) => ({ ...prev, [item.project_number]: e.target.value }))
                  }
                  className="w-24 border rounded px-2 py-1"
                />
                <button
                  onClick={() => handleSubmit(item.project_number)}
                  disabled={submitting}
                  className={`px-3 py-1 rounded text-white ${
                    submitting ? "bg-gray-400" : "bg-blue-600 hover:bg-blue-700"
                  }`}
                >
                  {submitting ? "送信中…" : "入札"}
                </button>
              </div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}

	•	ポイント：
	•	entries.some(...) で「自分がこの案件でエントリー済みか」を判定し、入力 UI を切り替える
	•	価格は少数第一位まで入力可能 (step="0.1")
	•	3 人分入力完了を entries.length === 3 で判定し、自動的に結果ページへルーティング
	•	バリデーションとして「最小～最大価格範囲」「必須入力」を実装

3-2-4. ラウンド結果ページ (/app/game/[session_id]/round/[round]/result/page.tsx)
	•	役割：API から取得した結果を表示し、「次へ」ボタンで次ラウンドに進む（または最終ランキングへ）

"use client";

import { useEffect, useState } from "react";
import { useSupabaseClient, useSession } from "@supabase/auth-helpers-react";
import { useRouter, useParams } from "next/navigation";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";

type Winner = {
  participant_id: string;
  project_number: number;
  winning_price: number;
  profit: number;
};

export default function RoundResultPage() {
  const supabase = useSupabaseClient();
  const session = useSession();
  const router = useRouter();
  const { session_id, round } = useParams() as { session_id: string; round: string };
  const [winners, setWinners] = useState<Winner[]>([]);
  const [profits, setProfits] = useState<Record<string, number>>({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 1. 未ログイン → /signin へリダイレクト
  useEffect(() => {
    if (session === null) {
      router.push("/signin?redirectTo=/game/" + session_id + "/round/" + round + "/result");
    }
  }, [session, router, session_id, round]);

  // 2. 結果取得
  useEffect(() => {
    const fetchResult = async () => {
      try {
        const res = await fetch(`/api/game/${session_id}/round/${round}/result`);
        const json = await res.json();
        if (!res.ok) throw new Error(json.error);
        setWinners(json.winners);
        setProfits(json.profits);
        setLoading(false);
      } catch (e: any) {
        setError("結果の取得に失敗しました");
        setLoading(false);
      }
    };
    fetchResult();
  }, [session_id, round]);

  // 3. 「次のラウンド / ランキングへ」ボタン
  const handleNext = () => {
    const nextRound = Number(round) + 1;
    if (nextRound <= 4) {
      router.push(`/game/${session_id}/round/${nextRound}`);
    } else {
      router.push(`/game/${session_id}/summary`);
    }
  };

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div>
      <h3 className="text-lg font-semibold mb-4">ラウンド {round} 結果</h3>
      <table className="w-full border-collapse mb-4">
        <thead>
          <tr className="bg-gray-100">
            <th className="border px-2 py-1">案件番号</th>
            <th className="border px-2 py-1">落札者</th>
            <th className="border px-2 py-1">落札価格</th>
            <th className="border px-2 py-1">利益</th>
          </tr>
        </thead>
        <tbody>
          {winners.map((w) => (
            <tr key={w.participant_id} className="odd:bg-white even:bg-gray-50">
              <td className="border px-2 py-1">{w.project_number}</td>
              <td className="border px-2 py-1">{w.participant_id}</td>
              <td className="border px-2 py-1">{w.winning_price.toFixed(1)}</td>
              <td className="border px-2 py-1">{w.profit}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <h4 className="font-semibold mb-2">累積利益（現在）</h4>
      <ul className="space-y-1 mb-4">
        {Object.entries(profits).map(([pid, prof]) => (
          <li key={pid}>
            {pid}：{prof} 億円
          </li>
        ))}
      </ul>
      <button
        onClick={handleNext}
        className="bg-blue-600 text-white px-4 py-2 rounded"
      >
        {Number(round) < 4 ? `ラウンド${Number(round) + 1}へ` : "最終ランキングへ"}
      </button>
    </div>
  );
}

3-2-5. 最終ランキング画面 (/app/game/[session_id]/summary/page.tsx)

"use client";

import { useEffect, useState } from "react";
import { useSession } from "@supabase/auth-helpers-react";
import { useRouter, useParams } from "next/navigation";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";

type Ranking = {
  participant_id: string;
  total_profit: number;
};

export default function SummaryPage() {
  const session = useSession();
  const router = useRouter();
  const { session_id } = useParams() as { session_id: string };
  const [rankings, setRankings] = useState<Ranking[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (session === null) {
      router.push("/signin?redirectTo=/game/" + session_id + "/summary");
    }
  }, [session, router, session_id]);

  useEffect(() => {
    const fetchSummary = async () => {
      try {
        const res = await fetch(`/api/game/${session_id}/summary`);
        const json = await res.json();
        if (!res.ok) throw new Error(json.error);
        setRankings(json.rankings);
        setLoading(false);
      } catch (e: any) {
        setError("ランキングの取得に失敗しました");
        setLoading(false);
      }
    };
    fetchSummary();
  }, [session_id]);

  const handleRestart = () => {
    router.push("/lobby");
  };

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div>
      <h3 className="text-lg font-semibold mb-4">最終ランキング</h3>
      <table className="w-full border-collapse mb-4">
        <thead>
          <tr className="bg-gray-100">
            <th className="border px-2 py-1">順位</th>
            <th className="border px-2 py-1">参加者</th>
            <th className="border px-2 py-1">累積利益</th>
          </tr>
        </thead>
        <tbody>
          {rankings.map((r, idx) => (
            <tr key={r.participant_id} className={`${idx === 0 ? "bg-yellow-100" : ""}`}>
              <td className="border px-2 py-1">{idx + 1}位</td>
              <td className="border px-2 py-1">{r.participant_id}</td>
              <td className="border px-2 py-1">{r.total_profit} 億円</td>
            </tr>
          ))}
        </tbody>
      </table>
      <button
        onClick={handleRestart}
        className="bg-green-600 text-white px-4 py-2 rounded"
      >
        再戦する
      </button>
    </div>
  );
}


⸻

4. 詳細な技術仕様・各モジュール設計

4-1. Supabase クライアント設定 (src/lib/supabaseClient.ts)

import { createClient, SupabaseClient } from "@supabase/supabase-js";

const supabaseUrl       = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey   = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase: SupabaseClient = createClient(supabaseUrl, supabaseAnonKey);

	•	ポイント：
	•	NEXT_PUBLIC_SUPABASE_URL / NEXT_PUBLIC_SUPABASE_ANON_KEY は .env.local / Vercel の環境変数に設定
	•	このクライアントを各 API Route ＆フロントで共有

4-2. サインアップ / サインイン (/app/signup/page.tsx, /app/signin/page.tsx)
	•	サインアップ画面（実装例概略）

"use client";
import { useSupabaseClient } from "@supabase/auth-helpers-react";
import { useRouter } from "next/navigation";
import { useState } from "react";

export default function SignupPage() {
  const supabase = useSupabaseClient();
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [submitting, setSubmitting] = useState(false);

  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSubmitting(true);
    const { data, error: signError } = await supabase.auth.signUp({
      email,
      password,
    });
    if (signError) {
      setError(signError.message);
      setSubmitting(false);
      return;
    }
    // サインアップ成功時→ メール認証待ち画面へ遷移
    router.push("/signin?notify=check-email");
  };

  return (
    <main className="p-6 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-4">サインアップ</h1>
      {error && <p className="text-red-500 mb-2">{error}</p>}
      <form onSubmit={handleSignup} className="space-y-4">
        <div>
          <label htmlFor="email">メールアドレス</label>
          <input
            id="email"
            type="email"
            required
            className="w-full border rounded px-3 py-2"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <div>
          <label htmlFor="password">パスワード</label>
          <input
            id="password"
            type="password"
            required
            className="w-full border rounded px-3 py-2"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <button
          type="submit"
          disabled={submitting}
          className={`w-full py-2 rounded text-white ${
            submitting ? "bg-gray-400" : "bg-blue-600 hover:bg-blue-700"
          }`}
        >
          {submitting ? "送信中…" : "登録する"}
        </button>
      </form>
    </main>
  );
}


	•	サインイン画面（実装例概略）

"use client";
import { useSupabaseClient, useSession } from "@supabase/auth-helpers-react";
import { useRouter, useSearchParams } from "next/navigation";
import { useState, useEffect } from "react";

export default function SigninPage() {
  const supabase = useSupabaseClient();
  const session = useSession();
  const router = useRouter();
  const searchParams = useSearchParams();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [submitting, setSubmitting] = useState(false);

  // サインイン済み→ /lobby へリダイレクト
  useEffect(() => {
    if (session) {
      router.push("/lobby");
    }
  }, [session, router]);

  const handleSignin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSubmitting(true);

    const { data, error: signInError } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    if (signInError) {
      setError(signInError.message);
      setSubmitting(false);
      return;
    }
    // 認証成功
    const redirectTo = searchParams.get("redirectTo") || "/lobby";
    router.push(redirectTo);
  };

  return (
    <main className="p-6 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-4">サインイン</h1>
      {searchParams.get("notify") === "check-email" && (
        <p className="text-green-600 mb-2">
          メールに認証リンクを送りました。メールを確認してください。
        </p>
      )}
      {error && <p className="text-red-500 mb-2">{error}</p>}
      <form onSubmit={handleSignin} className="space-y-4">
        <div>
          <label htmlFor="email">メールアドレス</label>
          <input
            id="email"
            type="email"
            required
            className="w-full border rounded px-3 py-2"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <div>
          <label htmlFor="password">パスワード</label>
          <input
            id="password"
            type="password"
            required
            className="w-full border rounded px-3 py-2"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <button
          type="submit"
          disabled={submitting}
          className={`w-full py-2 rounded text-white ${
            submitting ? "bg-gray-400" : "bg-blue-600 hover:bg-blue-700"
          }`}
        >
          {submitting ? "認証中…" : "サインイン"}
        </button>
      </form>
    </main>
  );
}



⸻

4-3. API Route 実装サンプル

4-3-1. /src/app/api/game/route.ts （ゲーム作成／一覧取得）

// src/app/api/game/route.ts

import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

// Supabase Admin Client (サービスロールキー使用)
const supabaseUrl        = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabaseAdmin      = createClient(supabaseUrl, supabaseServiceKey);

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { created_by } = body as { created_by: string };
    if (!created_by) {
      return NextResponse.json({ error: "created_by が必須です" }, { status: 400 });
    }
    // ゲームセッション作成
    const { data: session, error: sessionError } = await supabaseAdmin
      .from("game_sessions")
      .insert([{ created_by, status: "waiting", round: 1 }])
      .select("*")
      .single();

    if (sessionError || !session) {
      return NextResponse.json({ error: sessionError?.message || "作成に失敗" }, { status: 500 });
    }
    // 参加者登録
    const { data: participant, error: partError } = await supabaseAdmin
      .from("participants")
      .insert([{ user_id: created_by, game_session_id: session.id }])
      .select("*")
      .single();

    if (partError || !participant) {
      return NextResponse.json({ error: partError?.message || "参加者登録に失敗" }, { status: 500 });
    }

    return NextResponse.json({ game_session: session }, { status: 201 });
  } catch (e) {
    return NextResponse.json({ error: "サーバーエラー" }, { status: 500 });
  }
}

export async function GET() {
  try {
    // waiting ステータスのセッション一覧を返す
    const { data: sessions, error } = await supabaseAdmin
      .from("game_sessions")
      .select("id, status, round, created_by, created_at")
      .eq("status", "waiting")
      .order("created_at", { ascending: true });

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    // 参加者数も含める（サブクエリ的に participants を join してもよい）
    const detailed = await Promise.all(
      sessions.map(async (s) => {
        const { count } = await supabaseAdmin
          .from("participants")
          .select("*", { count: "exact", head: true })
          .eq("game_session_id", s.id);
        return { ...s, participants_count: count || 0 };
      })
    );
    return NextResponse.json({ sessions: detailed }, { status: 200 });
  } catch (e) {
    return NextResponse.json({ error: "サーバーエラー" }, { status: 500 });
  }
}

4-3-2. /src/app/api/game/[id]/join/route.ts

// src/app/api/game/[id]/join/route.ts

import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const supabaseUrl        = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabaseAdmin      = createClient(supabaseUrl, supabaseServiceKey);

export async function POST(request: Request, { params }: { params: { id: string } }) {
  const { id } = params;
  try {
    const body = await request.json();
    const { user_id } = body as { user_id: string };
    if (!user_id) {
      return NextResponse.json({ error: "user_id が必須です" }, { status: 400 });
    }

    // すでに参加済みかチェック
    const { data: exists, count } = await supabaseAdmin
      .from("participants")
      .select("*", { count: "exact", head: true })
      .eq("game_session_id", id)
      .eq("user_id", user_id);

    if (count && count > 0) {
      return NextResponse.json({ error: "すでに参加済みです" }, { status: 400 });
    }

    // 参加者数チェック
    const { count: totalCount } = await supabaseAdmin
      .from("participants")
      .select("*", { count: "exact", head: true })
      .eq("game_session_id", id);

    if ((totalCount || 0) >= 3) {
      return NextResponse.json({ error: "定員いっぱいのため参加できません" }, { status: 403 });
    }

    // 参加登録
    const { data: participant, error: partError } = await supabaseAdmin
      .from("participants")
      .insert([{ user_id, game_session_id: id }])
      .select("*")
      .single();

    if (partError || !participant) {
      return NextResponse.json({ error: partError?.message || "参加登録に失敗" }, { status: 500 });
    }

    // 3 人になったらステータスを playing に更新
    if ((totalCount || 0) + 1 === 3) {
      const { error: updError } = await supabaseAdmin
        .from("game_sessions")
        .update({ status: "playing" })
        .eq("id", id);
      if (updError) {
        return NextResponse.json({ error: updError.message }, { status: 500 });
      }
    }

    return NextResponse.json({ participant }, { status: 201 });
  } catch (e) {
    return NextResponse.json({ error: "サーバーエラー" }, { status: 500 });
  }
}

4-3-3. /src/app/api/game/[id]/round/[n]/items/route.ts

// src/app/api/game/[id]/round/[n]/items/route.ts

import { NextResponse } from "next/server";
import { supabase } from "@/lib/supabaseClient";

export async function GET(
  request: Request,
  { params }: { params: { id: string; n: string } }
) {
  const { id, n } = params;
  const roundNumber = parseInt(n, 10);
  if (isNaN(roundNumber) || roundNumber < 1 || roundNumber > 4) {
    return NextResponse.json({ error: "ラウンド番号が不正です" }, { status: 400 });
  }

  try {
    const { data, error } = await supabase
      .from("game_items")
      .select("project_number, title, cost, min_price, max_price")
      .eq("game_session_id", id)
      .eq("round", roundNumber)
      .order("project_number", { ascending: true });

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    if (!data || data.length === 0) {
      return NextResponse.json({ error: "案件情報が見つかりません" }, { status: 404 });
    }
    return NextResponse.json(data, { status: 200 });
  } catch (e) {
    return NextResponse.json({ error: "サーバーエラー" }, { status: 500 });
  }
}

4-3-4. /src/app/api/game/[id]/round/[n]/entry/route.ts

// src/app/api/game/[id]/round/[n]/entry/route.ts

import { NextResponse } from "next/server";
import { supabase } from "@/lib/supabaseClient";

export async function POST(
  request: Request,
  { params }: { params: { id: string; n: string } }
) {
  const { id, n } = params;
  const roundNumber = parseInt(n, 10);
  if (isNaN(roundNumber) || roundNumber < 1 || roundNumber > 4) {
    return NextResponse.json({ error: "ラウンド番号が不正です" }, { status: 400 });
  }

  try {
    const body = await request.json();
    const { participant_id, project_number, price, base_location } = body as {
      participant_id: string;
      project_number: number;
      price?: number;
      base_location?: string;
    };

    // 参加者チェック
    const { data: part, error: partErr } = await supabase
      .from("participants")
      .select("id, user_id")
      .eq("id", participant_id)
      .eq("game_session_id", id)
      .single();
    if (partErr || !part) {
      return NextResponse.json({ error: "参加者情報が不正です" }, { status: 403 });
    }

    // ラウンド 3 かその他かでバリデーションを分岐
    if (roundNumber === 3) {
      if (!base_location) {
        return NextResponse.json({ error: "本拠地を選択してください" }, { status: 400 });
      }
      // 本拠地が有効な値かチェック (例：東北/関東/中部/関西/西南日本)
      const validLocations = ["東北", "関東", "中部", "関西", "西南日本"];
      if (!validLocations.includes(base_location)) {
        return NextResponse.json({ error: "本拠地が不正です" }, { status: 400 });
      }
    } else {
      // 1,2,4 ラウンドの価格入力バリデーション
      if (price === undefined || isNaN(price)) {
        return NextResponse.json({ error: "価格を入力してください" }, { status: 400 });
      }
      // min_price, max_price を取得して範囲チェック
      const { data: items, error: itemErr } = await supabase
        .from("game_items")
        .select("min_price, max_price")
        .eq("game_session_id", id)
        .eq("round", roundNumber)
        .eq("project_number", project_number)
        .single();
      if (itemErr || !items) {
        return NextResponse.json({ error: "案件情報が不正です" }, { status: 400 });
      }
      const { min_price, max_price } = items;
      if (price < min_price || price > max_price) {
        return NextResponse.json(
          { error: `価格は ${min_price}～${max_price} の範囲で入力してください` },
          { status: 400 }
        );
      }
    }

    // 二重登録チェック
    const { count } = await supabase
      .from("entries")
      .select("*", { count: "exact", head: true })
      .eq("game_session_id", id)
      .eq("round", roundNumber)
      .eq("participant_id", participant_id)
      .eq("project_number", project_number);
    if (count && count > 0) {
      return NextResponse.json({ error: "既にエントリー済みです" }, { status: 400 });
    }

    // Insert into entries
    const { data: entry, error: entryErr } = await supabase
      .from("entries")
      .insert([
        {
          game_session_id: id,
          participant_id,
          round: roundNumber,
          project_number,
          price: roundNumber === 3 ? null : price,
          base_location: roundNumber === 3 ? base_location : null,
        },
      ])
      .select("*")
      .single();

    if (entryErr || !entry) {
      return NextResponse.json({ error: entryErr?.message || "登録失敗" }, { status: 500 });
    }

    return NextResponse.json({ entry }, { status: 201 });
  } catch (e) {
    return NextResponse.json({ error: "サーバーエラー" }, { status: 500 });
  }
}

4-3-5. /src/app/api/game/[id]/round/[n]/result/route.ts

// src/app/api/game/[id]/round/[n]/result/route.ts

import { NextResponse } from "next/server";
import { supabase } from "@/lib/supabaseClient";

/**
 * Price 点＋地域点取得のヘルパー関数
 * （スライドの表をそのままコード化）
 */
function getRegionPoint(location: string, project_number: number): number {
  // ラウンド3 用の地域点テーブル例 (project_number ごとに異なる点数になる場合は調整)
  const regionTable: Record<string, number> = {
    "東北": 1,
    "関東": 3,
    "中部": 2,
    "関西": 1,
    "西南日本": 2,
  };
  return regionTable[location] || 0;
}

export async function GET(
  request: Request,
  { params }: { params: { id: string; n: string } }
) {
  const { id, n } = params;
  const roundNumber = parseInt(n, 10);
  if (isNaN(roundNumber) || roundNumber < 1 || roundNumber > 4) {
    return NextResponse.json({ error: "ラウンド番号が不正です" }, { status: 400 });
  }

  try {
    // 1. 参加者のエントリーを取得
    const { data: allEntries, error: entriesErr } = await supabase
      .from("entries")
      .select("*")
      .eq("game_session_id", id)
      .eq("round", roundNumber);

    if (entriesErr) {
      return NextResponse.json({ error: entriesErr.message }, { status: 500 });
    }

    if (!allEntries || allEntries.length < 3) {
      return NextResponse.json({ error: "まだ全員のエントリーが揃っていません" }, { status: 409 });
    }

    // 2. game_items からコスト・min/max 取得
    const itemFetches = allEntries.map((e) =>
      supabase
        .from("game_items")
        .select("cost, min_price, max_price")
        .eq("game_session_id", id)
        .eq("round", roundNumber)
        .eq("project_number", e.project_number)
        .single()
    );
    const itemsResponses = await Promise.all(itemFetches);
    // 各レスポンスから cost, min_price, max_price を取り出す
    // (省略: error チェック etc.) 
    const enriched = allEntries.map((e, idx) => ({
      ...e,
      cost: itemsResponses[idx].data?.cost || 0,
      min_price: itemsResponses[idx].data?.min_price || 0,
      max_price: itemsResponses[idx].data?.max_price || 0,
    }));

    // 3. 落札判定
    let winnerId: string = "";
    let winningPrice: number = 0;
    const profits: Record<string, number> = {};

    if (roundNumber === 1 || roundNumber === 2) {
      // 最低価格を Winner とする
      const validEntries = enriched.filter((e) => e.price !== null);
      validEntries.sort((a, b) => (a.price! > b.price! ? 1 : -1));
      winnerId = validEntries[0].participant_id;
      winningPrice = validEntries[0].price!;
      const cost = validEntries[0].cost;
      // Winner の利益
      profits[winnerId] = winningPrice - cost - 2 - 2;
      // Losers の利益
      enriched.forEach((e) => {
        if (e.participant_id !== winnerId) {
          profits[e.participant_id] = 0 - 2 - 2;
        }
      });
    } else if (roundNumber === 3) {
      // 価格点 + 地域点 + 技術投資 (今回は技術投資なし)
      const scored = enriched.map((e) => {
        const pricePoint = e.max_price - (e.price || 0);
        const regionPoint = getRegionPoint(e.base_location || "", e.project_number);
        const totalPoint = pricePoint + regionPoint;
        return { ...e, totalPoint };
      });
      scored.sort((a, b) => (a.totalPoint < b.totalPoint ? 1 : -1)); // 降順
      winnerId = scored[0].participant_id;
      winningPrice = scored[0].price || 0;
      const cost = scored[0].cost;
      const bonus = getRegionPoint(scored[0].base_location || "", scored[0].project_number);
      profits[winnerId] = bonus + (winningPrice - cost) - 2 - 2;
      scored.forEach((e) => {
        if (e.participant_id !== winnerId) {
          profits[e.participant_id] = 0 - 2 - 2;
        }
      });
    } else {
      // round 4: 2 番目に安い価格を Winner とする
      const validEntries = enriched.filter((e) => e.price !== null);
      validEntries.sort((a, b) => (a.price! > b.price! ? 1 : -1));
      if (validEntries.length === 1) {
        winnerId = validEntries[0].participant_id;
        winningPrice = validEntries[0].price!;
      } else {
        winnerId = validEntries[1].participant_id;
        winningPrice = validEntries[1].price!;
      }
      const cost = validEntries.find((e) => e.participant_id === winnerId)?.cost || 0;
      profits[winnerId] = winningPrice - cost - 2 - 2;
      enriched.forEach((e) => {
        if (e.participant_id !== winnerId) {
          profits[e.participant_id] = 0 - 2 - 2;
        }
      });
    }

    // 4. results テーブルに保存
    const { data: result, error: resultErr } = await supabase
      .from("results")
      .insert([
        {
          game_session_id: id,
          round: roundNumber,
          project_number: enriched[0].project_number,
          winner_participant_id: winnerId,
          winning_price: winningPrice,
          profit_winner: profits[winnerId],
          profit_losers: JSON.stringify(
            Object.fromEntries(
              Object.entries(profits).filter(([pid]) => pid !== winnerId)
            )
          ),
        },
      ])
      .select("*")
      .single();

    if (resultErr || !result) {
      return NextResponse.json({ error: resultErr?.message || "結果保存に失敗" }, { status: 500 });
    }

    // 5. 累積利益を算出して返却
    const { data: allProfits, error: allProfErr } = await supabase
      .rpc("calculate_cumulative_profits", { session_id: id }); // Postgres 関数で集計を行う想定
    if (allProfErr) {
      return NextResponse.json({ error: allProfErr.message }, { status: 500 });
    }
    // allProfits は [ { participant_id, total_profit }, … ] の形

    return NextResponse.json(
      { winners: [result], profits: Object.fromEntries(allProfits.map((r: any) => [r.participant_id, r.total_profit])) },
      { status: 200 }
    );
  } catch (e) {
    return NextResponse.json({ error: "サーバーエラー" }, { status: 500 });
  }
}

	•	ポイント：
	•	RPC（Postgres 関数）を使って累積利益をまとめて計算する例を示したが、単純に SQL の SUM で済ませてもよい
	•	RLS が適切に設定されているため、参加者とゲームセッションの紐づきチェックは Supabase 上で担保される

⸻

4-4. 環境変数・設定ファイル
	•	.env.local（ローカル開発用）

NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ…
SUPABASE_SERVICE_ROLE_KEY=eyJ…


	•	next.config.js（必要なら設定）

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    appDir: true,
  },
  eslint: {
    // ビルド時に警告をエラーにしない場合は false に設定
    ignoreDuringBuilds: true,
  },
};

module.exports = nextConfig;


	•	tsconfig.json（型定義設定）

{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}



⸻

4-5. Graphical なデータフロー例（シーケンス図イメージ）
	1.	ラウンド1 入札～結果取得フロー

ユーザーA            フロント (Next.js)           API Route (/entry)           Supabase DB
  │                        │                               │                           │
  │  1. GET /items         │                               │                           │
  │─────────────────────▶│   fetch items                  │                           │
  │                        │──────────────────────────────▶│                           │
  │                        │                               │ SELECT game_items…      │
  │                        │                               │◀──────────────────────────│
  │                        │   2. JSON(items)               │                           │
  │◀─────────────────────│                               │                           │
  │                        │                               │                           │
  │  3. ユーザーが価格入力 │                               │                           │
  │─────────────────────▶│                               │                           │
  │                        │ 4. POST /entry (price=xx)      │                           │
  │                        │──────────────────────────────▶│                           │
  │                        │                               │ INSERT INTO entries…   │
  │                        │                               │◀──────────────────────────│
  │                        │   5. JSON(entry)              │                           │
  │◀─────────────────────│                               │                           │
  │                        │                               │                           │
  │  6. (他ユーザーも同様) │                               │                           │
  │                        │                               │                           │
  │  7. entries が3件揃う  │                               │                           │
  │─────────────────────▶│                               │                           │
  │                        │ 8. GET /result                │                           │
  │                        │──────────────────────────────▶│                           │
  │                        │                               │ SELECT entries…         │
  │                        │                               │◀──────────────────────────│
  │                        │    9. 計算ロジック            │                           │
  │                        │                               │ (pricePoint +… )         │
  │                        │                               │                           │
  │                        │    10. INSERT INTO results…   │                           │
  │                        │──────────────────────────────▶│                           │
  │                        │                               │                           │
  │                        │    11. JSON(result)           │                           │
  │◀─────────────────────│                               │                           │
  │                        │                               │                           │
  │  12. 結果表示           │                               │                           │


⸻

5. プロジェクト管理／リリース手順
	1.	GitHub に Push → Vercel に自動デプロイ
	•	main ブランチにマージされたら、Vercel が自動的にビルド (npm run build) → npm run start → 新バージョン公開
	•	プレビュー環境は各 Pull Request ごとに URL が発行される
	2.	環境変数設定（Vercel）
	•	NEXT_PUBLIC_SUPABASE_URL / NEXT_PUBLIC_SUPABASE_ANON_KEY / SUPABASE_SERVICE_ROLE_KEY を Vercel プロジェクト設定で追加
	•	本番用 Supabase 情報には必ず NEXT_PUBLIC_ プレフィックスをつけて公開キーとし、サービスロールキーのみはサーバーサイドで参照
	3.	マイグレーション管理
	•	Supabase ダッシュボードの SQL Editor で DDL を実行
	•	もしくは supabase migrations コマンドを使ってローカルで SQL ファイルを管理 → 本番環境に適用
	4.	テスト・QA
	•	ローカルで npm run dev → 各画面の動作確認
	•	Supabase のデータベースに表示されるテーブルを確認し、RLS が正しく適用されているかチェック
	•	Vercel のプレビュー環境で実際のユーザーシナリオ（3 人同時プレイ）をエミュレート
	5.	運用
	•	30 人規模の授業中は、一度に 3 人ずつグループに分けてゲームを回す
	•	複数のセッションを同時に立ち上げてもデータベースに負荷はかからない想定だが、万が一同時 2 コネクション制限に抵触する場合は Supabase 有料プラン検討
	•	授業後はデータをエクスポートし、成績評価や振り返りに活用

⸻

■ まとめ
	•	基本設計書 では、全体像を示し、どのテーブル・API・画面が必要かを明示。
	•	詳細設計書 では、実際の DDL、API エンドポイント仕様、フロントエンドのコンポーネント設計やデータフローまで深掘りして定義しました。
	•	これにより、プロジェクトメンバーが「どこに何を追加すれば、どのような挙動になるのか」を明確に把握できる状態となります。

以上をもとに開発を進めていただければ、入札シミュレーションゲームを小規模チーム開発しながら、プロジェクト管理の勉強にもつなげられるはずです。ご参考になれば幸いです。